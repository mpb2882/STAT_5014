---
title: "R Notebook"
output:
  html_document: default
  html_notebook: default
---

# Problem 1

If you are reading this, then the file has been created correctly.  :'( that there was no swirl problem.



# Problem 2
```{r, echo=F}
# Set the seed to maintain constant data set
#### I had to change the length.out for this to work on my computer.  It kept saying it couldn't perform the operations because the vector size was too large. 
set.seed(12345)
y <- seq(from = 1, to = 100, length.out = 1e+04) + rnorm(1e+04)

#Create a for loop to calculate SST




#Compute SST using vector operations
yPrime <- t(y)

#Create an n vector for identity matrix, then make a J matrix
n <- c(10000)
I <- matrix(0, nrow = n, ncol = n)
I[row(I)==col(I)] <- 1

J <- matrix(1, nrow = n, ncol = n)

#Create SST using matrix multiplication
SSTCen <- I - J/n
system.time({SST <- yPrime%*%SSTCen%*%y})
SST
```


# Problem 3
```{r, echo=F}
set.seed(1256)
theta <- as.matrix(c(1, 2), nrow = 2)
X <- cbind(1, rep(1:10, 10))
h <- X %*% theta + rnorm(100, 0, 0.2)

#Get the results for lm for comparison
lm(h~0+X)



```


# Problem 4

Instead of computing $(X'X)^{-1}$ It would be better to treat that inverse value as $A^{-1}$ and put it beside $\hat\beta$ as $A$. This would allow us to use the solve function without having to perform a large matrix multiplication, and it should be much faster that way.


# Problem 5
```{r, echo=F}
 set.seed(12456) 
    
    G <- matrix(sample(c(0,0.5,1),size=16000,replace=T),ncol=10)
    R <- cor(G) # R: 10 * 10 correlation matrix of G
    G <- NULL
    C <- kronecker(R, diag(1600)) # C is a 16000 * 16000 block diagonal matrix
    id <- sample(1:16000,size=932,replace=F)
    q <- sample(c(0,0.5,1),size=15068,replace=T) # vector of length 15068
    A <- C[id, -id] # matrix of dimension 932 * 15068
    B <- C[-id, -id] # matrix of dimension 15068 * 15068
    p <- runif(932,0,1)
    r <- runif(15068,0,1)
    C<-NULL #save some memory space
    
    Binverse <- solve(C[-id, -id])
    system.time({
        Binverse <- solve(B)
        y <- (p + (A%*%Binverse %*% (q - r)))
        })
#It took my computer 260 seconds to solve for y using the basic method given in the example
    
    system.time({
        pA <- p + A
        qr <- q - r
        Binverse <- solve(B)
        speedY <- solve(B, pA %*% qr)
    })
```


# Problem 6
If you can see this, the pull request has been successfully completed.
